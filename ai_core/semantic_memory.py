"""Semantic episodic memory module.

文件结构说明：

```
SemanticMemory -> 核心类
  _embed()     -> 文本哈希嵌入函数
  add_memory() -> 存入对话记录
  query_memory() -> 相似内容检索
```
"""

import datetime
import hashlib
import logging
from typing import List, Dict, Any

try:
    import numpy as np  # type: ignore
except ImportError:  # pragma: no cover
    np = None

try:
    import faiss  # type: ignore
except ImportError:  # pragma: no cover
    faiss = None

from .constants import LOG_LEVEL, DEFAULT_MEMORY_SAVE_URL, DEFAULT_MEMORY_QUERY_URL
from .service_api import call_memory_save, call_memory_query

logger = logging.getLogger(__name__)
logger.setLevel(LOG_LEVEL)


class SemanticMemory:
    """Simple vector-based semantic memory using FAISS if desired.

    基于向量的语义记忆模块，可选择使用 FAISS 加速。
    """

    def __init__(self, vector_dim: int = 384, use_faiss: bool | None = None, save_url: str | None = DEFAULT_MEMORY_SAVE_URL, query_url: str | None = DEFAULT_MEMORY_QUERY_URL) -> None:
        """Initialize memory store and optional FAISS index.

        初始化记忆存储及 FAISS 索引（如果可用）。

        Parameters
        ----------
        vector_dim: int, optional
            Dimensionality of embedding vectors. 嵌入向量的维度，默认为 ``384``。
        use_faiss: bool | None, optional
            Whether to use FAISS for similarity search. ``None`` 代表自动判断
            (如果已安装 FAISS 就使用)。
        save_url: str | None, optional
            Remote service to store memory records. 记忆存储服务地址。
        query_url: str | None, optional
            Remote service to query memory records. 记忆查询服务地址。
        """
        self.vector_dim = vector_dim  # 向量维度
        self.records: List[Dict[str, Any]] = []  # 存储对话记录
        self.save_url = save_url
        self.query_url = query_url
        if use_faiss is None:
            use_faiss = faiss is not None
        if use_faiss and faiss is not None:
            self.index = faiss.IndexFlatL2(vector_dim)  # 使用 FAISS 建立索引
        else:
            self.index = None  # 回退到纯 Python 搜索

    def _embed(self, text: str):
        """Convert text to a deterministic vector using hashing.

        使用哈希算法将文本转换为确定性向量。
        """
        digest = hashlib.sha256(text.encode("utf-8")).digest()  # 生成文本哈希
        logger.debug("Embedding text: %s", text)
        if np is not None:
            arr = np.frombuffer(digest, dtype=np.uint8).astype("float32") / 255.0
            if arr.size < self.vector_dim:
                arr = np.pad(arr, (0, self.vector_dim - arr.size))
            return arr[: self.vector_dim]
        vec = [b / 255.0 for b in digest[: self.vector_dim]]
        if len(vec) < self.vector_dim:
            vec += [0.0] * (self.vector_dim - len(vec))
        return vec

    def add_memory(
        self,
        user_text: str,
        ai_response: str,
        mood_tag: str = "neutral",
        user_id: str = "unknown",
        touched: bool = False,
        touch_zone: int | None = None,
    ) -> None:
        """Add a conversation record into memory.

        新增一条对话记录到记忆库中。

        Parameters
        ----------
        user_text: str
            User input text.
        ai_response: str
            Reply generated by the system.
        mood_tag: str, optional
            Emotion label associated with the conversation. Defaults to
            ``"neutral"`` when unspecified.
            对应的情绪标签，默认值为 ``"neutral"``。
        touch_zone: int | None, optional
            Identifier for the touch sensor zone if a touch interaction
            occurred.  触摸传感器的区域编号，可为 ``None`` 表示无触摸。"""
        vec = self._embed(user_text)
        record = {
            "time": datetime.datetime.utcnow(),
            "user_text": user_text,
            "ai_response": ai_response,
            "mood_tag": mood_tag,
            "user_id": user_id,
            "touched": touched,
            "touch_zone": touch_zone,
            "topic_vector": vec,
        }
        self.records.append(record)
        logger.debug("Memory added: %s", record)
        if self.index is not None and np is not None:
            self.index.add(np.expand_dims(np.array(vec, dtype="float32"), 0))
        if self.save_url:
            ok = call_memory_save(record, self.save_url)
            if not ok:
                logger.info(
                    "Remote memory service failed; record kept locally.")
        
    def query_memory(
        self, prompt: str, top_k: int = 3, user_id: str | None = None
    ) -> List[Dict[str, Any]]:
        """Return most relevant past interactions for the prompt.

        根据提示查询最相关的历史对话。

        Parameters
        ----------
        prompt: str
            Query text used for retrieving memories.
        top_k: int, optional
            Number of records to return. 默认返回 3 条记录。
        user_id: str | None, optional
            If provided, filter memories belonging to this user.
            如提供该参数，则只返回该用户的历史记录。
        """
        query_vec = self._embed(prompt)
        logger.debug("Querying memory for: %s", prompt)
        if self.query_url:
            res = call_memory_query(prompt, top_k, self.query_url)
            if res is not None:
                return res
        candidates = (
            [r for r in self.records if user_id is None or r.get("user_id") == user_id]
        )
        if self.index is not None and np is not None and len(candidates) > 0:
            distances, indices = self.index.search(
                np.expand_dims(np.array(query_vec, dtype="float32"), 0), top_k
            )
            result = [candidates[i] for i in indices[0] if i < len(candidates)]
            logger.debug("FAISS results: %s", result)
            return result
        # fallback linear search
        # 回退到线性搜索
        def distance(a, b):
            return sum((x - y) ** 2 for x, y in zip(a, b)) ** 0.5  # 欧氏距离

        scores = [distance(r["topic_vector"], query_vec) for r in candidates]
        top_indices = sorted(range(len(scores)), key=lambda i: scores[i])[:top_k]
        results = [candidates[i] for i in top_indices]
        logger.debug("Linear search results: %s", results)
        return results  # 返回按距离排序的结果

    def save(self, path: str) -> None:
        """Save memory records to a JSON file.

        将所有记忆记录保存到 JSON 文件，方便持久化存储。
        """
        import json

        with open(path, "w", encoding="utf-8") as fh:
            json.dump(self.records, fh, default=str, ensure_ascii=False)
        logger.info("Memory saved to %s", path)

    def load(self, path: str) -> None:
        """Load memory records from a JSON file.

        从 JSON 文件恢复历史记忆记录。
        """
        import json

        try:
            with open(path, "r", encoding="utf-8") as fh:
                self.records = json.load(fh)
        except FileNotFoundError:
            logger.warning("Memory file %s not found", path)
            self.records = []
        if self.index is not None and np is not None and self.records:
            vecs = [r["topic_vector"] for r in self.records]
            self.index.add(np.array(vecs, dtype="float32"))
        logger.info("Loaded %d memory records", len(self.records))

    def last_mood(self, user_id: str | None = None) -> str | None:
        """Return the most recent mood tag for a user."""

        # 返回给定用户最近一次对话的情绪标签
        candidates = [r for r in self.records if user_id is None or r.get("user_id") == user_id]
        if not candidates:
            return None
        return candidates[-1].get("mood_tag")
